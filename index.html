<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Ranking Mobilizadores - BB (Corrigido)</title>

  <!-- SheetJS na raiz do repositório -->
  <script src="./xlsx.full.min.js"></script>

  <!-- Html2Canvas para exportar PNG -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
    :root {
      --bb-blue: #0033a0;
      --bb-yellow: #ffcc00;
      --bb-light-bg: #f4f6fb;
      --bb-card-bg: #ffffff;
      --bb-border: #dde3f0;
      --bb-text: #111827;
      --bb-muted: #6b7280;
      --radius-xl: 20px;
      --shadow-soft: 0 10px 26px rgba(15, 23, 42, 0.12);
      --font: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 24px 24px 40px;
      font-family: var(--font);
      background: var(--bb-light-bg);
      color: var(--bb-text);
    }

    .top-bar {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 18px;
    }

    .brand-pill {
      font-size: 10px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--bb-blue);
      background: #eaf1ff;
      color: var(--bb-blue);
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 700;
      color: var(--bb-blue);
    }

    .subtitle {
      font-size: 12px;
      color: var(--bb-muted);
      max-width: 820px;
    }

    .upload-area {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: #ffffff;
      border-radius: 16px;
      border: 1px solid var(--bb-border);
      box-shadow: 0 4px 12px rgba(148,163,253,0.16);
      margin-bottom: 22px;
    }

    .upload-area label {
      font-size: 12px;
      color: var(--bb-text);
      font-weight: 500;
    }

    input[type="file"] {
      font-size: 11px;
      max-width: 280px;
    }

    .status {
      font-size: 11px;
      color: var(--bb-muted);
      margin-left: auto;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(420px, 1fr));
      gap: 18px;
    }

    .card {
      position: relative;
      padding: 14px 16px 12px;
      border-radius: var(--radius-xl);
      background: var(--bb-card-bg);
      border: 1px solid var(--bb-border);
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
    }

    .card-title-wrap {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .card-title {
      font-size: 14px;
      font-weight: 700;
      color: var(--bb-blue);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .card-subtitle {
      font-size: 9px;
      color: var(--bb-muted);
    }

    .badges {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    .badge {
      font-size: 8px;
      padding: 3px 8px;
      border-radius: 999px;
      background: #f3f4ff;
      color: var(--bb-blue);
      border: 1px solid #d0dcff;
      font-weight: 500;
      white-space: nowrap;
    }

    .btn-png {
      font-size: 9px;
      padding: 4px 8px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: var(--bb-blue);
      color: #ffffff;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 4px 9px rgba(37, 99, 235, 0.25);
      white-space: nowrap;
    }

    .btn-png span.icon { font-size: 11px; }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 9px;
      margin-top: 2px;
      border-radius: 14px;
      overflow: hidden;
    }

    thead {
      background: linear-gradient(90deg, #f9fafb, #eef2ff);
    }

    th, td {
      padding: 4px 5px;
      text-align: left;
      border-bottom: 1px solid #eef2ff;
    }

    th {
      font-size: 8px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--bb-blue);
      font-weight: 600;
    }

    tbody tr:nth-child(odd) { background: #fafbff; }
    tbody tr:nth-child(even) { background: #ffffff; }
    tbody tr:last-child td { border-bottom: none; }

    .pos {
      width: 20px;
      font-weight: 700;
      color: var(--bb-blue);
    }

    .num {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .pct {
      font-weight: 700;
      text-align: right;
    }

    .pct.good  { color: #16a34a; }
    .pct.medium{ color: #f59e0b; }
    .pct.bad   { color: #dc2626; }

    .small-note {
      font-size: 8px;
      color: var(--bb-muted);
      margin-top: 1px;
    }

    .empty {
      font-size: 9px;
      color: var(--bb-muted);
      padding-top: 2px;
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div class="brand-pill">Ranking Mobilizadores • Banco do Brasil</div>
    <h1>Painéis de Ranking por Mobilizador</h1>
    <div class="subtitle">
      Leitura baseada nos cabeçalhos mesclados da planilha.
      Cada painel usa <strong>somente</strong> as colunas Intradia (ou %Atg do Icred) do seu Mobilizador.
      Uma mesma agência/carteira aparece em todos os rankings em que tiver indicador no bloco correspondente.
    </div>
  </div>

  <div class="upload-area">
    <label for="file">Selecione o arquivo <strong>.xlsx</strong> (relatório 6500):</label>
    <input type="file" id="file" accept=".xlsx" />
    <div class="status" id="status">Aguardando arquivo...</div>
  </div>

  <div class="grid" id="cards-container"></div>

  <script>
    const statusEl = document.getElementById("status");
    const cardsContainer = document.getElementById("cards-container");

    const DATA_START_ROW = 3; // 0-based: linha 4 da planilha

    document.getElementById("file").addEventListener("change", handleFile, false);

    function handleFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      statusEl.textContent = "Lendo planilha...";
      const reader = new FileReader();

      reader.onload = function (ev) {
        try {
          const data = new Uint8Array(ev.target.result);
          const wb = XLSX.read(data, { type: "array" });
          const sheetName = wb.SheetNames[0];
          const ws = wb.Sheets[sheetName];

          console.log("=== INÍCIO DO PROCESSAMENTO ===");
          const grid = buildGridWithMerges(ws);
          console.log("Grid construído com", grid.length, "linhas");
          processGrid(grid);
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Erro ao ler planilha. Confirme se é o layout padrão.";
        }
      };

      reader.readAsArrayBuffer(file);
    }

    // --- Utils básicos ---

    function norm(str) {
      if (str == null) return "";
      return str
        .toString()
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-z0-9%()]/g, "");
    }

    function toNumber(v) {
      if (v == null || v === "") return null;
      if (typeof v === "number") return v;
      let s = v.toString().trim().replace("%", "");
      if (s.includes(",") && s.includes(".")) {
        s = s.replace(/\./g, "").replace(",", ".");
      } else if (s.includes(",") && !s.includes(".")) {
        s = s.replace(",", ".");
      }
      const n = parseFloat(s);
      return isNaN(n) ? null : n;
    }

    function formatNumber(n) {
      if (n == null || isNaN(n)) return "";
      return Number(n).toLocaleString("pt-BR", { maximumFractionDigits: 2 });
    }

    function pctClass(p) {
      if (p == null) return "";
      if (p >= 105) return "good";
      if (p >= 90) return "medium";
      return "bad";
    }

    function colLetter(idx) {
      let n = idx + 1;
      let s = "";
      while (n > 0) {
        const r = (n - 1) % 26;
        s = String.fromCharCode(65 + r) + s;
        n = Math.floor((n - 1) / 26);
      }
      return s;
    }

    // --- Expande merges para ter cabeçalho coerente ---

    function buildGridWithMerges(ws) {
      const ref = ws["!ref"];
      const range = XLSX.utils.decode_range(ref);
      const rows = [];

      for (let R = range.s.r; R <= range.e.r; ++R) {
        const row = [];
        for (let C = range.s.c; C <= range.e.c; ++C) {
          const addr = XLSX.utils.encode_cell({ r: R, c: C });
          const cell = ws[addr];
          row.push(cell ? cell.v : null);
        }
        rows.push(row);
      }

      const merges = ws["!merges"] || [];
      console.log("Total de merges:", merges.length);
      
      merges.forEach(m => {
        const base = rows[m.s.r][m.s.c];
        for (let r = m.s.r; r <= m.e.r; r++) {
          for (let c = m.s.c; c <= m.e.c; c++) {
            rows[r][c] = base;
          }
        }
      });

      return rows;
    }

    // --- Detecção de blocos Mobilizador ---

    function detectMobilizerBlocks(grid) {
      console.log("\n--- DETECTANDO BLOCOS DE MOBILIZADOR ---");
      const row1 = grid[0];
      const blocks = [];
      let c = 0;
      
      while (c < row1.length) {
        const v = row1[c];
        if (v && typeof v === "string" && norm(v).includes("mobilizador")) {
          const label = v;
          let start = c;
          let end = c;
          
          // Continua enquanto for o mesmo label
          c++;
          while (c < row1.length && row1[c] === label) {
            end = c;
            c++;
          }
          
          blocks.push({ label, startCol: start, endCol: end });
          console.log(`Bloco encontrado: "${label}" | Colunas ${colLetter(start)}-${colLetter(end)} (índices ${start}-${end})`);
        } else {
          c++;
        }
      }
      
      console.log(`Total de blocos: ${blocks.length}`);
      return blocks;
    }

    function detectMetricsForBlock(grid, block) {
      const { label, startCol, endCol } = block;
      console.log(`\n--- ANALISANDO BLOCO: ${label} ---`);
      console.log(`Colunas do bloco: ${colLetter(startCol)}-${colLetter(endCol)}`);
      
      const isIcred = norm(label).includes("icred");
      
      if (isIcred) {
        console.log("Tipo: ICRED (buscando coluna %Atg)");
        let pctCol = null;
        
        // Procura %Atg em linhas 2 e 3
        for (let c = startCol; c <= endCol; c++) {
          for (let r = 1; r <= 2; r++) {
            const t = grid[r][c];
            const nt = norm(t);
            if (nt.includes("%") && (nt.includes("atg") || nt.includes("ating"))) {
              pctCol = c;
              console.log(`  ✓ Coluna %Atg encontrada: ${colLetter(c)} (índice ${c})`);
              console.log(`    Valor na célula: "${t}"`);
              break;
            }
          }
          if (pctCol != null) break;
        }
        
        if (pctCol == null) {
          console.log("  ✗ Coluna %Atg NÃO encontrada neste bloco");
          return null;
        }
        
        return { mode: "icred", pctCol, necCol: null, rlzCol: null };
      }

      // Para mobilizadores Intradia
      console.log("Tipo: INTRADIA (buscando Nec/Rlz/%Atg)");
      
      // Primeiro: identificar quais colunas são "Intradia" na linha 2
      const intradiaColumns = [];
      for (let c = startCol; c <= endCol; c++) {
        const t2 = grid[1][c];
        if (t2 && typeof t2 === "string" && norm(t2).includes("intradia")) {
          intradiaColumns.push(c);
        }
      }
      
      console.log(`  Colunas com "Intradia" na linha 2: ${intradiaColumns.map(c => colLetter(c)).join(", ")}`);
      
      if (intradiaColumns.length === 0) {
        console.log("  ⚠ Nenhuma coluna marcada como Intradia. Verificando linha 3 diretamente...");
        // Fallback: busca direto na linha 3 dentro do bloco
        intradiaColumns.push(...Array.from({length: endCol - startCol + 1}, (_, i) => startCol + i));
      }
      
      let necCol = null, rlzCol = null, pctCol = null;
      
      // Agora procura os indicadores na linha 3 dentro das colunas Intradia
      for (const c of intradiaColumns) {
        const t3 = grid[2][c];
        const n3 = norm(t3);
        
        if (n3.includes("nec") && n3.includes("dia") && necCol == null) {
          necCol = c;
          console.log(`  ✓ Nec. Dia encontrado: ${colLetter(c)} = "${t3}"`);
        }
        
        if (n3.includes("rlz") && n3.includes("dia") && rlzCol == null) {
          rlzCol = c;
          console.log(`  ✓ Rlz Dia encontrado: ${colLetter(c)} = "${t3}"`);
        }
        
        if ((n3.includes("%atg") || n3.includes("%ating") || (n3.includes("%") && n3.includes("atg"))) && pctCol == null) {
          pctCol = c;
          console.log(`  ✓ % Atg encontrado: ${colLetter(c)} = "${t3}"`);
        }
      }

      // Validação: precisa de pelo menos Nec e %Atg
      if (necCol == null || pctCol == null) {
        console.log(`  ✗ Configuração incompleta: Nec=${necCol!=null?colLetter(necCol):'null'}, %Atg=${pctCol!=null?colLetter(pctCol):'null'}`);
        console.log("  ⚠ Este bloco será ignorado");
        return null;
      }

      console.log(`  ✓ Configuração completa: Nec=${colLetter(necCol)}, Rlz=${rlzCol!=null?colLetter(rlzCol):'null'}, %Atg=${colLetter(pctCol)}`);
      return { mode: "intradia", necCol, rlzCol, pctCol };
    }

    // --- Processamento principal ---

    function processGrid(grid) {
      cardsContainer.innerHTML = "";

      if (!grid || grid.length <= DATA_START_ROW) {
        statusEl.textContent = "Planilha sem linhas de dados.";
        return;
      }

      const header = grid[0];

      const prefixIdx = findCol(header, ["prefixo"]);
      const depIdx    = findCol(header, ["dependencia", "dependência"]);
      const cartIdx   = findCol(header, ["carteira"]);
      const tipoIdx   = findCol(header, ["tipodacarteira", "tipocarteira", "tipo"]);

      console.log("\n--- COLUNAS PRINCIPAIS ---");
      console.log(`Prefixo: ${colLetter(prefixIdx)}`);
      console.log(`Dependência: ${colLetter(depIdx)}`);
      console.log(`Carteira: ${colLetter(cartIdx)}`);
      console.log(`Tipo: ${colLetter(tipoIdx)}`);

      if ([prefixIdx, depIdx, cartIdx, tipoIdx].some(i => i === -1)) {
        statusEl.textContent = "Não encontrei Prefixo / Dependência / Carteira / Tipo da Carteira na linha 1.";
        return;
      }

      const blocks = detectMobilizerBlocks(grid);

      const configs = [];
      for (const b of blocks) {
        const metrics = detectMetricsForBlock(grid, b);
        if (!metrics) continue;
        configs.push({
          key: norm(b.label),
          label: b.label,
          startCol: b.startCol,
          endCol: b.endCol,
          ...metrics
        });
      }

      console.log(`\n--- CONFIGURAÇÕES VÁLIDAS: ${configs.length} ---`);
      configs.forEach(cfg => {
        console.log(`${cfg.label}: ${cfg.mode.toUpperCase()}`);
      });

      // Ordena na sequência desejada
      const order = [
        "mobilizadordesembolsopf",
        "mobilizadordesembolsogiro",
        "mobilizadordesembolsoagro",
        "mobilizadoricred1590",
        "mobilizadorregularizadividasagro",
        "mobilizadorportfoliopriorizado",
        "mobilizadorportfoliopriorizad"
      ];
      configs.sort((a, b) => {
        const ia = order.indexOf(a.key);
        const ib = order.indexOf(b.key);
        if (ia === -1 && ib === -1) return 0;
        if (ia === -1) return 1;
        if (ib === -1) return -1;
        return ia - ib;
      });

      let any = false;

      console.log("\n--- GERANDO RANKINGS ---");
      for (const cfg of configs) {
        const ranking = buildRanking(grid, cfg, {
          prefixIdx, depIdx, cartIdx, tipoIdx
        });
        console.log(`Ranking "${cfg.label}": ${ranking.length} linhas`);
        const card = createRankingCard(cfg, ranking);
        cardsContainer.appendChild(card);
        if (ranking.length) any = true;
      }

      statusEl.textContent = any
        ? "Rankings gerados com sucesso!"
        : "Nenhuma linha elegível encontrada para os mobilizadores.";
      
      console.log("\n=== PROCESSAMENTO CONCLUÍDO ===");
    }

    function findCol(row, labels) {
      const targets = labels.map(norm);
      for (let c = 0; c < row.length; c++) {
        if (targets.includes(norm(row[c]))) return c;
      }
      return -1;
    }

    function buildRanking(grid, cfg, base) {
      const { prefixIdx, depIdx, cartIdx, tipoIdx } = base;
      const ranking = [];
      let processedLines = 0;
      let skippedLines = 0;

      for (let r = DATA_START_ROW; r < grid.length; r++) {
        const row = grid[r];

        const prefixo = row[prefixIdx];
        if (prefixo == null || prefixo === "") continue;

        processedLines++;

        const dependencia  = row[depIdx];
        const carteira     = row[cartIdx];
        const tipoCarteira = row[tipoIdx];

        let nec = null, rlz = null, pct = null;

        if (cfg.mode === "icred") {
          pct = toNumber(row[cfg.pctCol]);
          if (pct == null || isNaN(pct)) {
            skippedLines++;
            continue;
          }
        } else {
          // Intradia: precisa de Nec válido
          nec = toNumber(row[cfg.necCol]);
          if (nec == null || isNaN(nec)) {
            skippedLines++;
            continue;
          }

          // Tenta ler Rlz se existir
          if (cfg.rlzCol != null) {
            rlz = toNumber(row[cfg.rlzCol]);
          }

          // Tenta ler %Atg direto
          pct = toNumber(row[cfg.pctCol]);
          
          // Se não tem %Atg mas tem Rlz e Nec válidos, calcula
          if ((pct == null || isNaN(pct)) && rlz != null && !isNaN(rlz) && nec !== 0) {
            pct = (rlz / nec) * 100;
          }

          // Se ainda não tem %Atg válido, descarta
          if (pct == null || isNaN(pct)) {
            skippedLines++;
            continue;
          }
        }

        ranking.push({
          prefixo,
          dependencia,
          carteira,
          tipoCarteira,
          necDia: nec,
          rlzDia: rlz,
          pct
        });
      }

      ranking.sort((a, b) => (b.pct || 0) - (a.pct || 0));
      
      if (processedLines > 0) {
        console.log(`  "${cfg.label}": ${processedLines} linhas processadas, ${skippedLines} descartadas, ${ranking.length} no ranking`);
      }
      
      return ranking;
    }

    // --- UI: monta cards e exporta PNG ---

    function createRankingCard(cfg, ranking) {
      const card = document.createElement("div");
      card.className = "card";
      card.id = `card-${cfg.key}`;

      const header = document.createElement("div");
      header.className = "card-header";

      const left = document.createElement("div");
      left.className = "card-title-wrap";

      const title = document.createElement("div");
      title.className = "card-title";
      title.textContent = cfg.label;
      left.appendChild(title);

      const subtitle = document.createElement("div");
      subtitle.className = "card-subtitle";
      subtitle.textContent =
        cfg.mode === "icred"
          ? "Ranking por %Atg no bloco Icred 15/90."
          : "Ranking por %Atg Intradia do bloco deste mobilizador.";
      left.appendChild(subtitle);

      const right = document.createElement("div");
      right.className = "badges";

      const count = document.createElement("div");
      count.className = "badge";
      count.textContent = ranking.length
        ? `${ranking.length} linhas no ranking`
        : "Sem linhas elegíveis";
      right.appendChild(count);

      const cols = document.createElement("div");
      cols.className = "badge";
      cols.textContent = `Bloco ${colLetter(cfg.startCol)}–${colLetter(cfg.endCol)}`;
      right.appendChild(cols);

      const btn = document.createElement("button");
      btn.className = "btn-png";
      btn.innerHTML = '<span class="icon">⬇</span><span>Baixar PNG</span>';
      btn.onclick = () => downloadCardAsPNG(card, `ranking_${cfg.key}.png`);
      right.appendChild(btn);

      header.appendChild(left);
      header.appendChild(right);
      card.appendChild(header);

      if (!ranking.length) {
        const empty = document.createElement("div");
        empty.className = "empty";
        empty.textContent =
          "Nenhuma linha com indicador válido neste mobilizador.";
        card.appendChild(empty);
        return card;
      }

      const table = document.createElement("table");
      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      ["#", "Prefixo", "Agência", "Carteira", "Tipo", "Nec. Dia", "Rlz Dia", "% Atg"].forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      ranking.forEach((row, i) => {
        const tr = document.createElement("tr");

        const tdPos = document.createElement("td");
        tdPos.className = "pos";
        tdPos.textContent = i + 1;
        tr.appendChild(tdPos);

        const tdPref = document.createElement("td");
        tdPref.textContent = row.prefixo ?? "";
        tr.appendChild(tdPref);

        const tdDep = document.createElement("td");
        tdDep.textContent = row.dependencia ?? "";
        tr.appendChild(tdDep);

        const tdCart = document.createElement("td");
        tdCart.textContent = row.carteira ?? "";
        tr.appendChild(tdCart);

        const tdTipo = document.createElement("td");
        tdTipo.textContent = row.tipoCarteira ?? "";
        tr.appendChild(tdTipo);

        const tdNec = document.createElement("td");
        tdNec.className = "num";
        tdNec.textContent = row.necDia != null ? formatNumber(row.necDia) : "-";
        tr.appendChild(tdNec);

        const tdRlz = document.createElement("td");
        tdRlz.className = "num";
        tdRlz.textContent = row.rlzDia != null ? formatNumber(row.rlzDia) : "-";
        tr.appendChild(tdRlz);

        const tdPct = document.createElement("td");
        tdPct.className = "pct " + pctClass(row.pct);
        tdPct.textContent = row.pct != null ? row.pct.toFixed(2) + "%" : "-";
        tr.appendChild(tdPct);

        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      card.appendChild(table);

      const note = document.createElement("div");
      note.className = "small-note";
      note.textContent =
        cfg.mode === "icred"
          ? "Critério: %Atg no bloco Icred 15/90. Ordenado de maior para menor."
          : "Critério: Nec. Dia presente e %Atg válido no bloco deste mobilizador (colunas Intradia).";
      card.appendChild(note);

      return card;
    }

    async function downloadCardAsPNG(cardEl, filename) {
      const clone = cardEl.cloneNode(true);
      clone.style.position = "fixed";
      clone.style.left = "0";
      clone.style.top = "0";
      clone.style.width = "1280px";
      clone.style.maxWidth = "1280px";
      clone.style.margin = "0";
      clone.style.zIndex = "-1";
      clone.style.boxShadow = "none";
      clone.style.borderRadius = "24px";
      clone.style.background = "#ffffff";
      document.body.appendChild(clone);

      try {
        const canvas = await html2canvas(clone, {
          scale: 3,
          backgroundColor: "#ffffff",
          useCORS: true
        });
        const link = document.createElement("a");
        link.download = filename;
        link.href = canvas.toDataURL("image/png");
        link.click();
      } catch (e) {
        console.error(e);
        alert("Erro ao gerar PNG deste painel.");
      } finally {
        document.body.removeChild(clone);
      }
    }
  </script>
</body>
</html>